<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Single Post - ZenBlog Bootstrap Template</title>
 <div th:replace="~{partials/head}"></div>
</head>
<body class="single-post-page">

 <div th:replace="~{partials/header}"></div>
  <main class="main">

    <!-- Page Title -->
    <div class="page-title">
      <div class="container d-lg-flex justify-content-between align-items-center">
        <h1 class="mb-2 mb-lg-0">Single Post</h1>
        <nav class="breadcrumbs">
          <ol>
            <li><a href="/blogs">Home</a></li>
            <li class="current">Single Post</li>
          </ol>
        </nav>
      </div>
    </div><!-- End Page Title -->

    <div class="container">
      <div class="row">

        <div class="col-lg-8">

          <!-- Blog Details Section -->
          <section id="blog-details" class="blog-details section">
            <div class="container">

              <article class="article">

                <!-- <div class="post-img">
                  <img src="assets/img/blog/blog-1.jpg" alt="" class="img-fluid">
                </div> -->

                <h2 class="title" th:text="${post.title}">Dolorum optio tempore voluptas dignissimos cumque fuga qui quibusdam quia</h2>

                <div class="meta-top">
                  <ul>
                    <!-- <li class="d-flex align-items-center" ><i class="bi bi-person"></i> <a href="blog-details.html">John Doe</a></li> -->
                    <li class="d-flex align-items-center"><i class="bi bi-clock"></i> <time th:datetime="${#temporals.format(post.createdAt, 'yyyy-MM-dd')}" 
           th:text="${#temporals.format(post.createdAt, 'yy-MM-dd')}">Jan 1, 2022</time></li>
                    <li class="d-flex align-items-center"><i class="bi bi-chat-dots"></i> <span id="comment-count">0</span> &nbsp;comment</li> 
                  </ul>
                </div><!-- End meta top -->

                <div class="content" th:utext="${post.content}">
					blank
                </div><!-- End post content -->

              <!--   <div class="meta-bottom">
                  <i class="bi bi-folder"></i>
                  <ul class="cats">
                    <li><a href="#">Business</a></li>
                  </ul>

                  <i class="bi bi-tags"></i>
                  <ul class="tags">
                    <li><a href="#">Creative</a></li>
                    <li><a href="#">Tips</a></li>
                    <li><a href="#">Marketing</a></li>
                  </ul>
                </div>End meta bottom -->
				
				
				 <!-- Edit and Delete Buttons -->
<div th:if="${#authentication.name != 'anonymousUser' and #authentication.principal.blogId == blogId}" class="post-actions mt-4 d-flex gap-3">
  <a th:href="@{/blogs/{blogId}/posts/edit/{id}(blogId=${blogId}, id=${post.id})}" class="btn btn-outline-secondary btn-sm d-flex align-items-center">
    <i class="bi bi-pencil-square me-2"></i> 수정
  </a>
<form th:if="${#authentication.name != 'anonymousUser' and #authentication.principal.blogId == blogId}" th:action="@{/blogs/{blogId}/posts/delete/{id}(blogId=${blogId}, id=${post.id})}" method="post" onsubmit="return confirm('정말로 삭제하시겠습니까?');">
  <input type="hidden" name="_method" value="delete">
  <button type="submit" class="btn btn-outline-danger btn-sm d-flex align-items-center">
    <i class="bi bi-trash me-2"></i> 삭제
  </button>
</form>
  
  
</div>
              </article>

            </div>
          </section><!-- /Blog Details Section -->
          
          
          
          <!-- Blog Comments Section -->
<section id="blog-comments" class="blog-comments section">
  <div class="container">
    <h4 class="comments-count">댓글 <span id="comment-count2">0</span></h4>
    <!-- 댓글 목록이 표시될 영역 -->
    <div id="commentList">
      <!-- JavaScript로 동적으로 댓글 항목을 추가합니다. -->
    </div>
    
    <!-- 페이징 네비게이션 -->
    <nav aria-label="Comment pagination" class="mt-4">
      <ul class="pagination justify-content-center" id="pagination">
        <!-- 페이지 버튼들이 JavaScript로 동적으로 생성됩니다 -->
      </ul>
    </nav>
  </div>
</section>

<!-- Comment Form Section (댓글 작성 폼) -->
<section id="comment-form" class="comment-form section">
  <div class="container">
    <!-- 게시글 ID를 숨김 필드로 저장 (Thymeleaf로 값 채워짐) -->
    <input type="hidden" id="postId" th:value="${post.id}">
    <form id="commentForm">
      <div class="row">
        <div class="col-md-6 form-group">
          <input id="anonymousAuthor" type="text" class="form-control" placeholder="작성자*" required>
        </div>
        <div class="col-md-6 form-group">
          <input id="anonymousPassword" type="password" class="form-control" placeholder="비밀번호*" required>
        </div>
      </div>
      <div class="row">
        <div class="col form-group">
          <textarea id="content" class="form-control" placeholder="댓글 내용*" required></textarea>
        </div>
      </div>
      <div class="text-center">
        <button type="submit" class="btn btn-primary">댓글 등록</button>
      </div>
    </form>
  </div>
</section>

<script>
  // 게시글 ID는 Thymeleaf가 채워줌
  const postId = document.getElementById("postId").value;
  
  // 페이징 관련 변수
  let currentPage = 0;
  const pageSize = 10; // 백엔드 기본값과 동일
  let totalPages = 0;
  let totalElements = 0;

  // 댓글 목록 불러오기 (페이징 적용)
  function loadComments(page = 0) {
    // 페이지 파라미터 추가
    fetch(`/api/posts/${postId}/comments?page=${page}&size=${pageSize}&sort=createdAt,asc`)
      .then(response => response.json())
      .then(data => {
        // Page 객체에서 content와 페이징 정보 추출
        const comments = data.content;
        totalPages = data.totalPages;
        totalElements = data.totalElements;
        currentPage = data.number;
        
        const commentList = document.getElementById("commentList");
        const commentCount = document.getElementById("comment-count");
        const commentCount2 = document.getElementById("comment-count2");
        
        commentList.innerHTML = "";
        
        // 전체 댓글 수 표시
        if (commentCount) commentCount.innerText = totalElements;
        if (commentCount2) commentCount2.innerText = totalElements;

        // 댓글이 없는 경우
        if (comments.length === 0 && currentPage === 0) {
          commentList.innerHTML = '<p class="text-center text-muted">첫 번째 댓글을 작성해보세요!</p>';
        } else {
          // 각 댓글 생성
          comments.forEach(comment => {
            const commentDiv = document.createElement("div");
            commentDiv.className = "comment";
            commentDiv.setAttribute("data-comment-id", comment.id);

            commentDiv.innerHTML = `
              <div class="d-flex">
                <div class="comment-img">
                  <img src="assets/img/blog/default-avatar.jpg" alt="">
                </div>
                <div>
                  <h5>
                    <a href="#">${comment.author || "익명"}</a>
                    <a href="#" class="reply"><i class="bi bi-reply-fill"></i> Reply</a>
                    <button onclick="deleteComment(${comment.id})" class="btn btn-sm btn-outline-danger" style="margin-left: 10px;">삭제</button>
                  </h5>
                  <time datetime="${new Date(comment.createdAt).toISOString()}">
                    ${new Date(comment.createdAt).toLocaleString()}
                  </time>
                  <p>${comment.content}</p>
                </div>
              </div>
            `;

            // 답글이 있는 경우 처리
            if (comment.replies && comment.replies.length > 0) {
              const repliesDiv = document.createElement("div");
              repliesDiv.className = "comment-reply";
              comment.replies.forEach(reply => {
                const replyDiv = document.createElement("div");
                replyDiv.className = "comment comment-reply";
                replyDiv.setAttribute("data-comment-id", reply.id);
                replyDiv.innerHTML = `
                  <div class="d-flex">
                    <div class="comment-img">
                      <img src="assets/img/blog/default-avatar.jpg" alt="">
                    </div>
                    <div>
                      <h5>
                        <a href="#">${reply.author || "익명"}</a>
                        <button onclick="deleteComment(${reply.id})" class="btn btn-sm btn-outline-danger" style="margin-left: 10px;">삭제</button>
                      </h5>
                      <time datetime="${new Date(reply.createdAt).toISOString()}">
                        ${new Date(reply.createdAt).toLocaleString()}
                      </time>
                      <p>${reply.content}</p>
                    </div>
                  </div>
                `;
                repliesDiv.appendChild(replyDiv);
              });
              commentDiv.appendChild(repliesDiv);
            }

            commentList.appendChild(commentDiv);
          });
        }
        
        // 페이징 네비게이션 업데이트
        updatePagination();
      })
      .catch(error => console.error("댓글 불러오기 오류:", error));
  }

  // 페이징 네비게이션 업데이트
  function updatePagination() {
    const pagination = document.getElementById("pagination");
    pagination.innerHTML = "";
    
    // 페이지가 2개 이상일 때만 페이징 표시
    if (totalPages <= 1) return;
    
    // 이전 버튼
    const prevLi = document.createElement("li");
    prevLi.className = `page-item ${currentPage === 0 ? 'disabled' : ''}`;
    prevLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage - 1}); return false;">이전</a>`;
    pagination.appendChild(prevLi);
    
    // 페이지 번호 버튼들
    const maxVisiblePages = 5; // 한 번에 표시할 최대 페이지 수
    let startPage = Math.max(0, currentPage - Math.floor(maxVisiblePages / 2));
    let endPage = Math.min(totalPages - 1, startPage + maxVisiblePages - 1);
    
    // startPage 조정 (endPage가 마지막에 가까울 때)
    if (endPage - startPage < maxVisiblePages - 1) {
      startPage = Math.max(0, endPage - maxVisiblePages + 1);
    }
    
    // 첫 페이지로 가기 (생략 기호와 함께)
    if (startPage > 0) {
      const firstLi = document.createElement("li");
      firstLi.className = "page-item";
      firstLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(0); return false;">1</a>`;
      pagination.appendChild(firstLi);
      
      if (startPage > 1) {
        const ellipsisLi = document.createElement("li");
        ellipsisLi.className = "page-item disabled";
        ellipsisLi.innerHTML = `<span class="page-link">...</span>`;
        pagination.appendChild(ellipsisLi);
      }
    }
    
    // 페이지 번호들
    for (let i = startPage; i <= endPage; i++) {
      const pageLi = document.createElement("li");
      pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
      pageLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${i}); return false;">${i + 1}</a>`;
      pagination.appendChild(pageLi);
    }
    
    // 마지막 페이지로 가기 (생략 기호와 함께)
    if (endPage < totalPages - 1) {
      if (endPage < totalPages - 2) {
        const ellipsisLi = document.createElement("li");
        ellipsisLi.className = "page-item disabled";
        ellipsisLi.innerHTML = `<span class="page-link">...</span>`;
        pagination.appendChild(ellipsisLi);
      }
      
      const lastLi = document.createElement("li");
      lastLi.className = "page-item";
      lastLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${totalPages - 1}); return false;">${totalPages}</a>`;
      pagination.appendChild(lastLi);
    }
    
    // 다음 버튼
    const nextLi = document.createElement("li");
    nextLi.className = `page-item ${currentPage === totalPages - 1 ? 'disabled' : ''}`;
    nextLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage + 1}); return false;">다음</a>`;
    pagination.appendChild(nextLi);
  }

  // 페이지 변경
  function changePage(page) {
    if (page < 0 || page >= totalPages) return;
    loadComments(page);
    // 댓글 섹션으로 스크롤
    document.getElementById('blog-comments').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  // 댓글 작성 (POST 요청) - 백엔드 API 경로 수정
  document.getElementById("commentForm").addEventListener("submit", function(event) {
    event.preventDefault();

    const anonymousAuthor = document.getElementById("anonymousAuthor").value;
    const anonymousPassword = document.getElementById("anonymousPassword").value;
    const content = document.getElementById("content").value;

    // RequestDto 형식에 맞춰 JSON으로 전송
    const requestData = {
      postId: parseInt(postId),
      content: content,
      anonymousAuthor: anonymousAuthor,
      anonymousPassword: anonymousPassword,
      parentId: null // 최상위 댓글인 경우 null
    };

    fetch(`/api/posts/${postId}/comments`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestData)
    })
    .then(response => {
      if (!response.ok) {
        throw new Error("댓글 등록에 실패하였습니다.");
      }
      return response.json();
    })
    .then(() => {
      // 댓글 작성 후 첫 페이지로 이동하여 최신 댓글 표시
      loadComments(0);
      document.getElementById("commentForm").reset();
    })
    .catch(error => console.error("댓글 작성 오류:", error));
  });

  // 댓글 삭제 (DELETE 요청)
  function deleteComment(commentId) {
    const anonymousPassword = prompt("댓글 삭제를 위한 비밀번호를 입력하세요:");
    if (anonymousPassword === null || anonymousPassword.trim() === "") {
      return;
    }

    fetch(`/api/comments/${commentId}`, {
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ password: anonymousPassword })
    })
    .then(response => {
      if (response.ok) {
        loadComments(currentPage); // 현재 페이지 유지하며 목록 갱신
      } else if (response.status === 403) {
        alert("비밀번호가 올바르지 않습니다.");
      } else {
        alert("댓글 삭제에 실패했습니다.");
      }
    })
    .catch(error => console.error("댓글 삭제 오류:", error));
  }

  // 이벤트 위임을 통해 "reply" 링크 클릭 처리
  document.addEventListener('click', function(e) {
    const replyLink = e.target.closest('.reply');
    if (replyLink) {
      e.preventDefault();
      const commentBlock = replyLink.closest('.comment');
      if (commentBlock.querySelector('.reply-form')) return;

      const replyForm = document.createElement('form');
      replyForm.className = 'reply-form mt-3';
      replyForm.innerHTML = `
        <div class="row">
          <div class="col-md-6 form-group">
            <input type="text" class="form-control reply-author" placeholder="작성자*" required>
          </div>
          <div class="col-md-6 form-group">
            <input type="password" class="form-control reply-password" placeholder="비밀번호*" required>
          </div>
        </div>
        <div class="row">
          <div class="col form-group">
            <textarea class="form-control reply-content" placeholder="답글 내용*" required></textarea>
          </div>
        </div>
        <div class="text-center">
          <button type="submit" class="btn btn-primary btn-sm">답글 등록</button>
          <button type="button" class="btn btn-secondary btn-sm cancel-reply">취소</button>
        </div>
      `;
      commentBlock.appendChild(replyForm);

      // 답글 폼 제출 이벤트 처리
      replyForm.addEventListener('submit', function(ev) {
        ev.preventDefault();
        const replyAuthor = replyForm.querySelector('.reply-author').value;
        const replyPassword = replyForm.querySelector('.reply-password').value;
        const replyContent = replyForm.querySelector('.reply-content').value;
        const parentCommentId = commentBlock.getAttribute('data-comment-id');
        
        const replyData = {
          postId: parseInt(postId),
          content: replyContent,
          anonymousAuthor: replyAuthor,
          anonymousPassword: replyPassword,
          parentId: parseInt(parentCommentId)
        };

        fetch(`/api/posts/${postId}/comments`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(replyData)
        })
        .then(response => {
          if (!response.ok) {
            throw new Error("답글 등록에 실패하였습니다.");
          }
          return response.json();
        })
        .then(() => {
          loadComments(currentPage); // 현재 페이지 유지하며 목록 갱신
        })
        .catch(error => console.error("답글 등록 오류:", error));
      });

      // 답글 폼 취소 버튼 처리
      replyForm.querySelector('.cancel-reply').addEventListener('click', function() {
        replyForm.remove();
      });
    }
  });
  
  // 페이지 로드 시 댓글 목록 불러오기
  window.addEventListener("load", function() {
    loadComments(0);
  });
</script>